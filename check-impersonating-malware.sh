#!/usr/bin/env bash
# Check malware processes impersonated as Linux kernel processes
#
# Reference:
#
# * Detecting Linux kernel process masquerading with command line forensics | APNIC Blog
#   https://blog.apnic.net/2020/04/27/detecting-linux-kernel-process-masquerading-with-command-line-forensics/
# * pgrep(1) manual page
#
# Copyright 2022 林博仁(Buo-ren, Lin) <Buo.Ren.Lin@gmail.com>
# SPDX-License-Identifier: CC-BY-SA-4.0+
set \
    -o errexit \
    -o nounset \
    -o pipefail

CHECK_MALWARE_DEBUG="${CHECK_MALWARE_DEBUG:-false}"
BACKUP_BASEDIR="${BACKUP_BASEDIR:-/opt/backup}"

# Disable broken nounset feature for Bash <4.3
if test "${BASH_VERSINFO[0]}" -lt 4 \
    || {
        test "${BASH_VERSINFO[0]}" -eq 4 \
            && test "${BASH_VERSINFO[1]}" -lt 3
    }; then
    set +o nounset
fi

flag_required_command_not_found=false
required_external_commands=(
    date
    gzip
    mkdir
    pgrep
)
for required_external_command in "${required_external_commands[@]}"; do
    if ! command -v "${required_external_command}" &>/dev/null; then
        flag_required_command_not_found=true
        printf \
            'Error: This program requires "%s" command to be available in your command search PATHs.\n' \
            "${required_external_command}" \
            1>&2
    fi
done
if test "${flag_required_command_not_found}" == true; then
    printf \
        'Error: Runtime dependency check failed, check documentation.\n' \
        1>&2
    exit 1
fi

if test "${EUID}" != 0; then
    printf \
        'Error: This program is required to be run as the superuser(root) to access low-level process information.\n' \
        1>&2
    exit 2
fi

# Common script variables
# shellcheck disable=SC2034
{
    if ! test -v 'BASH_SOURCE[0]'; then
        script='(stdin)'
        script_filename='(stdin)'
        script_name='(stdin)'
        script_dir=
        script_basecommand="bash -s --"
    else
        script="${BASH_SOURCE[0]}"
        script_filename="${script##*/}"
        script_name="${script_filename%%.*}"
        script_dir="${script%/*}"
        script_basecommand="${0}"
    fi
    script_args=("${@}")
}

timestamp="$(
    date \
        +%Y%m%d%H%M%S
)"
flag_malware_found=false

kernel_thread_like_process_ids=()
while IFS= read -r pid; do
    kernel_thread_like_process_ids+=("${pid}")
done < <(
    regex_kernel_thread_like_process_cmdline='^\[.*\]'

    # NOTE: pgrep(1) accepts extended regular expressions(ERE)
    pgrep \
        --full \
        "${regex_kernel_thread_like_process_cmdline}"
)
unset pid

for kernel_thread_like_process_id in "${kernel_thread_like_process_ids[@]}"; do
    process_potentially_fake_cmdline="$(< "/proc/${kernel_thread_like_process_id}/cmdline")"

    if test "${CLEAN_MALWARE_DEBUG}" == true; then
        printf \
            'DEBUG: Checking process %s("%s")...\n' \
            "${kernel_thread_like_process_id}" \
            "${process_potentially_fake_cmdline}" \
            1>&2
    fi

    process_library_memory_mappings="$(< "/proc/${kernel_thread_like_process_id}/maps")"

    # Real kernel thread will not have library memory mappings
    if test -n "${process_library_memory_mappings}"; then
        flag_malware_found=true
        impersonating_malware_process_cmdline="${process_potentially_fake_cmdline}"
        impersonating_malware_process_id="${kernel_thread_like_process_id}"
        backup_dir="${BACKUP_BASEDIR}/${script_name}-MALWARE-DO-NOT-RUN-${timestamp}"
        mkdir \
            --parents \
            "${backup_dir}"
        printf \
            'WARNING: Kernel thread impersonating malware process "%s" found(PID=%s)!\n' \
            "${impersonating_malware_process_cmdline}" \
            "${impersonating_malware_process_id}" \
            1>&2
        payload_backup="${backup_dir}/payload.${impersonating_malware_process_id}.gz"
        if ! \
            gzip \
                <"/proc/${impersonating_malware_process_id}/exe" \
                >"${payload_backup}"; then
            printf \
                'Warning: Unable to dump the payload executable for process %s.\n' \
                "${impersonating_malware_process_id}" \
                1>&2
        else
            printf \
                'Info: Payload executable for process %s backed-up to %s.\n' \
                "${impersonating_malware_process_id}" \
                "${payload_backup}" \
                1>&2
        fi
    fi
done

if test "${flag_malware_found}" == true; then
    printf \
        'WARNING: Malware process(es) found, please check!\n' \
        1>&2
    exit 99
else
    printf \
        'Info: No malware process found.\n'
    exit 0
fi
